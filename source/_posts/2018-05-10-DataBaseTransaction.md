---
title: 理解数据库事务和锁
date: 2018-05-10 11:39:47
tags: 数据库
---



# 数据库事务



> 数据库事务(Database Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。

一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：

> * 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

> * 当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

<!-- more -->

但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）	。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。

## 事务特性

并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。
> * 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。
> * 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。
> * 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
> * 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。


## 事务举例


用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：

1、从A账号中把余额读出来（500）。</br>
2、对A账号做减法操作（500-100）。</br>
3、把结果写回A账号中（400）。</br>
4、从B账号中把余额读出来（500）。</br>
5、对B账号做加法操作（500+100）。</br>
6、把结果写回B账号中（600）。</br>

### 原子性：
保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。

### 一致性
在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。

### 隔离性
在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。
如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。

### 持久性

一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）。



# 数据库读现象

“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。

## 脏读

脏读是指在数据库访问中，当一个事务A正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务B也访问这个数据，然后使用了这个数据。然后A又进行回滚操作，则事务B访问的数据是无效的。即上述转账例子中，转账事务进行到一半的时候，此时另外一个事务去读了A账号的余额，然后转账事务回滚，A的余额变回以前的值。此时后面读余额的事务即为脏读。

## 不可重复读

不可重复读，即在一个事务中分多次读同一数据，但是在前后两次读取之间,另外一个事务也在访问该数据，可能进行了修改，这样就造成了第一次事务的前后两次读取的数据不一致的现象。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。

## 幻读

幻读与不可重复读之间很容易让人混淆。举一个简单的例子来理解一下幻读：</br>

users： id 主键

1、事务A：select * from users where id = 1;</br>
2、事务B：insert into `users`(`id`, `name`) values (1, 'big cat');</br>
3、事务A：insert into `users`(`id`, `name`) values (1, 'big cat');</br>

> A ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。
> B ：干扰事务，目的在于扰乱 T1 的正常的事务执行。</br>

关于这种现象，可以称之为幻读。在mysql中，关于这两个事务，可能会有两个结果，A全部B失败，或者B成功A失败。这取决于数据库的不同隔离级别。

例如，在 RR 隔离级别下，1、2是正常执行的，3则会报主键冲突，对于A事务的业务是执行失败的，这里事务A就发生了幻读，因为它读取的数据状态不能满足它的下一步业务。

# 数据库并发控制

## 并发控制

>  在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。

我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。


数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。前面关于事务的概念以及读现象举的例子其实都是并发的场景。再举例讨论一个实际场景中的例子：两个火车票代售点，同时读取12306数据库中的某趟列车的车票数量为X，然后同时卖出一张票，然后同时提交了X-1到数据库中，这样就造成了卖了两张票，而库中记录只减了一张。生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。



## 数据库隔离

在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足久性。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。

ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。</br>

隔离级别                     | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read）| 幻读（Phantom Read）
 :---                       | :---               | :---                       | :--- 
未提交读（Read uncommitted） | 可能	              | 可能	                 | 可能
已提交读（Read committed）	 | 不可能	          | 可能                   | 可能
可重复读（Repeatable read）	 | 不可能	          | 不可能                     | 可能
可串行化（Serializable ）    |不可能	          | 不可能	              | 不可能	 

> * 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
> * 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
> * 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。 在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
> * 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞




## 锁

当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。可以简单理解为当某个事务在操作开始时，锁定某一个对象，在这个事务操作结束之前，不允许其他事务操作这个对象。下面是常见的锁分类：

### 锁的分类
1、按照锁定的对象的粒度划分：表级锁、行级锁、页级锁（mysql）</br>
2、按锁级别划分：共享锁（shared lock，读锁，shared lock）、排他锁（exclusive lock，写锁，write lock）</br>
3、按使用方式划分，可分为乐观锁、悲观锁</br>

各种锁的比较：
> * 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
> * 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
> * 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。


# 参考
> 淘宝MySQL博客 http://mysql.taobao.org/monthly/2016/01/01/ </br>
> 美团点评技术团队 https://tech.meituan.com/innodb-lock.html








